---
title: 'Домашняя работа #3'
author: '*Константин Гергенредер, группа номер 3*'
date: "04.03.2020"
output:
  prettydoc::html_pretty:
    theme: hpstr
  pdf_document: default
  word_document: default
---
```{r global, include = FALSE, warning=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
```

<center> [![Alt text](https://i.imgur.com/CebjKkZ.png)](https://vk.com/dsminor2k18) </center>

--------------
```{r}

library(prettydoc) # пакет для темы, если не работает - скачать в CRAN. Если совсем все плохо - удалить строчку prettydoc::html_pretty: и theme: hpstr, заменить на   html_document: default
library(readr)
library(dplyr)
library(ggplot2)
library(stringr)
library(igraph)
library(plotly)
library(visNetwork)
library(DT) # работа с таблицами

load("~/shared/minor2_2019/data/netflix_network_largest_component.rda")
```

### Задачи исследования
#### 1. Построить сеть по данным
#### 2. Ответить на поставленные исследовательские вопросы
#### 3. Определить центральность вершин
#### 4. Выявить сообщества
#### 5. Визуализировать полученные данные
#### 6. Интерпретировать результаты, сформулировать идею для создания системы рекомендации фильмов

--------------
     
## 1. Построим сеть по данным. Розовые точки - режиссеры, голубые - актеры.
```{r fig.width= 20, fig.height= 20}
nt <- graph_from_data_frame(movie_crew_net, directed = FALSE) 
net_pos = rep(NA, nrow(net_prop))
for (i in 1:nrow(net_prop)){
net_pos[i] = (net_prop %>% filter(name == V(nt)$name[i]))$position
}
V(nt)$actor_director = net_pos
V(nt)$color = ifelse(V(nt)$actor_director == "director", "pink", "lightblue")
nt2 <- toVisNetworkData(nt)
visNetwork(nodes = nt2$nodes, edges = nt2$edges, height = 600, width = "100%") %>%   visPhysics(solver = "barnesHut") %>% visInteraction(navigationButtons = TRUE) 
```

--------------

## 2. Сформулируем исследовательские вопросы.

### Первый вопрос
><p align="justify">**Каким образом на основе имеющихся данных совместной работы актеров и режиссеров возможно рекомендовать фильмы кинозрителям?**  
Вопрос возможсти использования данных в алгоритмах рекомендаций фильмов является ключевым в данной работе. Предполагается, что используя существующие данные пользователям онлайн кинотеатров будет предлагаться фильм с максимальным "попаданием" в список интересов условного пользователя. Как именно это можно реализовать и каких данных для этого может недостаточно можно узнать в ответе на первый исследовательский вопрос в финальном выводе исследования. </p>

### Второй вопрос
><p align="justify">**Какой режисер является самым востребованным среди остальных актеров и режиссеров?**  
В предоставленном датасете большой список имен режисеров и актеров. Исследовательский вопрос заключается в том, существует ли самый востребованный режиссер и кем он является (как его зовут). Востребованность заключается в том, что у него наибольшее число связей с остальными актерами и режисерами. Ответ на этот вопрос напрямую связан с первым исследовательским вопросом, так как он позволяет рассмотреть закономерности связей внутри сети. Для последнего необходимо выявление сообществ. Ответ на второй исследовательский вопрос также находится в финальном выводе. </p>

--------------

## 3. Определим центральность вершин.

### 3.1 **Центральность по посредничеству, битвинность (betweenness)**
<p align="justify">**Hint!** В этом случае важны вершины, которые являются посредниками между группами, находятся на "выгодном" месте. Выгодным местом считается положение актера или режиссера, который связывает несколько больших групп и является посредником между ними. Смотрим не на количество связей, а на количество вершин.  </p>
```{r fig.width= 20, fig.height= 20}
#Оставим названия наиболее значимых вершин.
plot(nt, vertex.label = if_else(betweenness(nt) > 500, V(nt)$name, " "),
     vertex.size = betweenness(nt)/100, 
     vertex.label.cex = betweenness(nt)/1000,
     layout = layout.davidson.harel, frame = TRUE, main = 'Визуализация сети с определением центральности вершин методом посредничества (betweenness)')
```

><center> __Вывод по 3.1.__ </center><p align="justify">  
Ключевыми фигурами данной сети являются режиссеры Jay Karas и Jay Chapman, а также актер Jim Gaffigan. У этих вершин наибольшая битвинность. Простыми словами, через этих людей связываются различные большие группы. Они являются посредниками. Если потенциальный актер захочет узнать по поводу свободных ролей, ему лучше обратиться к этим людям, так как через них откроется доступ к новой информации. Актер Jim Gaffigan попал в этот список потому что он напряму связан с обоими режиссерами, у которых большой показатель посреднических связей.</p>

### 3.2 **Центральность по близости (closeness)**
<p align="justify">**Hint!** Рассматриваем вершины с наиболее короткими путями до остальных (т.е. наиболее близкие к остальным). В данном случае является ближайшая связь отдельного человека к центру кинобизнеса, где происходит набиольшое количество взаимодействий (работ над одним фильмом).
```{r fig.width= 20, fig.height= 20}
plot(nt,
     vertex.size = closeness(nt)*2000, 
     vertex.label.cex = closeness(nt)*700,
     layout = layout.davidson.harel, frame = TRUE,main = 'Визуализация сети с определением центральности вершин методом близости (closeness)')
```

> <center> __Вывод по 3.2.__ </center><p align="justify">  
Наивысшим значнием близости обладает вершина актера Jim Gaffigan. Второе и третье место за теми же режиссерами Jay Chapman и Jay Karas. Наивысший показатель closeness означает, что вершина находится ближе всего по отношению к остальным точкам и через нее наиболее короткие маршруты к другим частям сети. В нашем случае это означает, что через Jim Gaffigan можно выйти на большинство актеров и режиссеров для обсуждения работы или получения рекомендаций для фильма. </p>

### 3.3 **Центральность по степени (degree)**
```{r fig.width= 20, fig.height= 20}
# Оставим подписи к самым важным именам, у которых связей больше 5. (Важным считается тот человек, который работал с более чем 5-ю другими актерами или режисерами).

plot(nt, vertex.label = if_else(degree(nt) > 5, V(nt)$name, " "),
     vertex.size = degree(nt)*3, 
     vertex.label.cex = degree(nt)/5,
     layout = layout.davidson.harel, frame = TRUE, main = 'Визуализация сети с определением центральности вершин методом степени (degree)')
```

> <center> __Вывод по 3.3.__ </center><p align="justify">  
По показателю центральности через количество ребер можно узнать "важные" вершины, у которых наибольшее количество прямых связей. В этом методе расчета центральности ТОП-3 занимают режиссеры Jay Chapman (11), Jay Karas (10) и Shannon Hartman (8). Простыми словами нашего примера, это означает, кто эти три вершины обладают наибольшим числом связей с другими. Или, иными словами, каждый человек этого топа обладает наибольшим количеством взаимодействий с другими актерами или режисерами. </p>

### 3.4 **Общий вывод**
```{r}
mv = data.frame(degree(nt))
mv = tibble::rownames_to_column(mv, "Name")
mv = mutate(mv, betweenness(nt)) %>% mutate (closeness (nt))
datatable(mv, class = 'cell-border stripe', colnames = c('Имя', 'Degree', 'Betweenness', 'Closeness'), caption = 'Таблица 1. Сводные данные по мерам центральности ')
```

> <p align="justify"> Рейтинг режиссеров и актеров по различным методам расчета центральности  
Битвинность: Jay Chapman (2014.5), Jay Karas (2000.5), Jim Gaffigan (1795.5)  
Близость: Jim Gaffigan (0.0032), Jay Karas (0.0031), Jay Chapman (0.0030)  
Количество ребер: Jay Chapman (11), Jay Karas (10), Shannon Hartman (8)  
Таким образом, можно выделить самого востребованного режиссера - __Jay Chapman__, т.к. у него самая высокая битвинность и количество ребер (он находится между несколькими большими группами людей, к которым можно дойти только через него, а также он связан напрямую с большим числом актеров и режиссеров).
</p>

--------------

# 4. Определим сообщества.

### 4.1 Метод **edge betweenness**:
<p align="justify">**Hint!** Иерархический метод, состоящий в последовательном удалении связей в порядке убывания показателей битвинности ребер (edge betweenness scores), то есть числа кратчайших путей, проходящих по рассматриваемому ребру. </p>
```{r fig.width= 20, fig.height= 20}
ebcommune <- edge.betweenness.community(nt)
plot(ebcommune, nt, frame = TRUE, main = 'Визуализация сети с выявлением сообществ методом битвинности (betweenness)')
print("Модулярность edge betweenness")
modularity(ebcommune)
```

> <center> __Вывод по 4.1__ </center><p align="justify">  
Качество разбиения можно оценить с помощью такого показателя, как модулярность. Модулярность равна доле рёбер от общего числа рёбер, которые попадают в данные группы минус ожидаемая доля рёбер, которые попали бы в те же группы, если бы они были распределены случайно. Значение модулярности лежит в интервале [-1,1]. Чем больше модулярность, тем лучше разбиение. В нашем примере она равна 0,77, что говорит о лучшем разбиении вершин на группы.  
По итогу выявления сообществ через битвинность, мы получили 10 различных сообществ. Наличие одного человека в сообществе означает то, что его связи с участниками этого сообщества намного сильнее, чем с другими участниками сети. Соединение графиков позволит выявить лидеров сообществ, для создания алгоритма рекомендации фильмов (см. последний график).</p>


### 4.2 Метод **Fast-Greedy**:

<p align="justify">**Hint!** Это иерархический подход. Первоначально каждая вершина представляет собой отдельное сообщество. Сообщества объединяются таким образом, чтобы это привело к наибольшему возрастанию модулярности. Останавливаемся, когда нет следующего шага, увеличивающего модулярность. 

```{r fig.width= 20, fig.height= 20}
fgcommune <- fastgreedy.community(nt)
plot(fgcommune,nt, frame = TRUE, main = 'Визуализация сети с выявлением сообществ методом Fast Greedy')
print("Модулярность Fast-Greedy")
modularity(fgcommune)
```

> <center> __Вывод по 4.2.__ </center><p align="justify">
Сообществ - 10. Модулярность данного метода выявления сообществ составляет 0.78.  Это выше значения метода битвинности, поэтому для рекомендаций мы будем использовать этот метод выявления сообществ. Как мы знаем, сети с высокой модулярностью имеют плотные связи между узлами внутри модулей, но слабые связи между узлами в различных модулях. На основе этого знания можно создать систему рекомендаций фильмов, используя выявленные сообщества.</p>

--------------

## Визуализируем результаты и сделаем заключительный вывод:
```{r fig.width= 20, fig.height= 20}
fgcommune <- fastgreedy.community(nt)
plot(fgcommune, nt, vertex.label = if_else(degree(nt) > 1, V(nt)$name, " "),
     vertex.size = degree(nt)*3, 
     vertex.label.cex = degree(nt)/5,
     layout = layout.davidson.harel, frame = TRUE, main = 'Визуализация сети с выявлением сообществ методом Fast Greedy и центральностью по степени (degree)')
```
```{r}
mc= mv %>% mutate (closeness (nt)) %>% mutate (membership(fgcommune))
datatable(mc, class = 'cell-border stripe', colnames = c('Имя', 'Degree', 'Betweenness', 'Closeness', 'Сообщество'), caption = 'Таблица 2. Сводные данные по мерам центральности и выявлению сообществ методом Fast-Greedy')
```

--------------

<center><font size="8">__Заключительный вывод__</font></center><p align="justify">
<font size="3">На основе проведенного исследования можно сделать предположения о том, как можно реализовать алгоритм рекомендации фильмов для пользователей. Для этого был проведен анализ центральности вершин и были выявлены сообщества. Все поставленные перед исследователем задачи выполненны. Построенные графики на основе сетей полностью отражают требуемую информацию. Все данные интерпретированны простым языком, чтобы потенциальному заказчику можно было понять информацию без специальных знаний в статистики и математике. Как следует из выполненного анализа данных, самым востребованным режиссером является __Jay Chapman__. Для нашего исследования это дает информацию о том, что через этого режиссера можно формировать рекомендации по фильмам. В списке рекомендаций, скорее всего, его имя будет появляться чаще остальных. Какой же алгоритм можно предложить для нашей задачи и ответа на первый исследовательский вопрос?  

>К примеру, в системе онлайн-кинотеатра пользователю предлагается выбрать список его любимых актеров. На основе Таблицы 2 система выбирает актера и рассматривает его сообщество. Так как в каждом сообществе актеры имеют наиболее тесную связь друг с другом, система может предложить другие фильмы, где снимались люди из окружения любимого актера пользователя. Также в сообществе находится режиссер, фильмы которого могут попасть в список рекомендованных. Чем больше актеров и режиссеров выберет пользователь, тем более точнее будет рекомендация.  
Однако для максимально точных рекомендаций данных о совместных работах актеров и режиссеров, конечно, не достаточно. Для рекомендаций целесообразно использовать личные интересы пользователя по жанрам, что даст дополнительные проценты к успешности рекомендации. Также желательно добавить в список отличительные особенности фильмов, к примеру, пользователю нравятся фильмы Американских режиссеров или Испанских актеров. Ввод дополнительной информации позволит спрогнозировать более точную рекомендацию для пользователя. В момент когда пользователь будет удивляться, насколько точной оказалась рекомендация, можно говорить об успешности модели. Magic для юзера, $$$ для заказчика :)</font></p>

--------------


<center>Data Science Minor 2019-2020</center>

